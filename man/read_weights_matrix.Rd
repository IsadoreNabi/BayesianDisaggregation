% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/data_io.R
\name{read_weights_matrix}
\alias{read_weights_matrix}
\title{Read a weights matrix from an Excel file}
\usage{
read_weights_matrix(path_weights)
}
\arguments{
\item{path_weights}{Character path to the weights Excel file.}
}
\value{
A \code{list} with:
\describe{
  \item{\code{P}}{\eqn{T \times K} numeric matrix of prior weights (rows sum to 1).}
  \item{\code{industries}}{Character vector of sector names (length \eqn{K}).}
  \item{\code{years}}{Integer vector of years (length \eqn{T}).}
}
}
\description{
Loads a sector-by-year weight table, normalizes weights to the simplex per year,
and returns a list with the \eqn{T \times K} prior matrix \code{P}, the sector
names, and the year vector. The first column is assumed to contain sector names
(renamed to \code{Industry}); all other columns are treated as years.
}
\details{
\strong{Expected layout.} One sheet with:
\itemize{
  \item First column: sector names (any header; renamed to \code{Industry}).
  \item Remaining columns: years; the function extracts a 4-digit year from each
        header using \code{stringr::str_extract(Year, "\\\\d{4}")}.
}
Values are parsed with \code{to_num_commas()}, missing rows are dropped, and
weights are normalized within each year to sum to 1. Any absent (sector, year)
entry becomes 0 when pivoting wide. Finally, rows are re-normalized with
\code{row_norm1()} for numerical safety.

\strong{Safeguards.}
\itemize{
  \item Rows with all-missing/zero after parsing are dropped by the filters.
  \item If no valid year columns are found, the function errors.
}
}
\examples{
\donttest{
# Suppose "WEIGHTS.xlsx" has first column "Industry" and year columns "2019","2020",...
# w <- read_weights_matrix("WEIGHTS.xlsx")
# str(w)
}

}
\seealso{
\code{\link{read_cpi}}, \code{\link{bayesian_disaggregate}}
}
